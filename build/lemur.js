// Generated by CoffeeScript 1.3.3
(function() {
  var C, JisonParser, L, Parser, core, name, op, postfix_ops, prefix_ops, regular_ops, root, _fn, _fn1, _fn2, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.root = root;

  L = {};

  root.lemur = L;

  core = L.core = {};

  (function() {
    var toString;
    toString = Object.prototype.toString;
    return core.to_type = function(o) {
      var s;
      s = toString.call(o);
      s = s.substring(8, s.length - 1);
      return s.toLowerCase();
    };
  })();

  core.s_trim = (_ref = String.prototype.trim) != null ? _ref : function() {
    return String(this).replace(/^\s+/, '').replace(/\s+$/, '');
  };

  (function() {
    var Noop, _ref1;
    Noop = function() {};
    return core.clone = (_ref1 = Object.create) != null ? _ref1 : function(o) {
      Noop.prototype = o;
      return new Noop();
    };
  })();

  if ((typeof exports !== "undefined" && exports !== null) && (typeof module !== "undefined" && module !== null)) {

  } else if (typeof provide !== "undefined" && provide !== null) {
    provide("lemur", L);
  }

  if ((typeof process !== "undefined" && process !== null ? process.title : void 0) === "node") {
    require('coffee-script');
    L = typeof lemur !== "undefined" && lemur !== null ? lemur : require('../core');
    JisonParser = (require('jison')).Parser;
    Parser = (function(_super) {

      __extends(Parser, _super);

      Parser.prototype.re = {
        lex_return: /^(return|function)/,
        "function": /^function/,
        strip_function: /^function\s*\([\w,]*\)\s*/,
        unwrap_function: /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/,
        whitespace: /\s+/g,
        regex_special: /[\^\$\*\+\?\.\(\)\|\{\}\[\]\\\/]/g,
        comment: /^\/\*.*\*\//,
        jison_special: /\<\<\w+\>\>/
      };

      function Parser(_arg) {
        var alternatives, entry, grammar, lexer, name, operators, rule, _i, _j, _len, _len1;
        lexer = _arg.lexer, operators = _arg.operators, grammar = _arg.grammar, this.start = _arg.start;
        this.lexer = {
          rules: []
        };
        this.grammar = {};
        this.operators = [];
        if (lexer != null) {
          for (_i = 0, _len = lexer.length; _i < _len; _i++) {
            rule = lexer[_i];
            this.lex_rule.apply(this, rule);
          }
        }
        if (operators != null) {
          for (_j = 0, _len1 = operators.length; _j < _len1; _j++) {
            entry = operators[_j];
            this.operator_rule(entry);
          }
        }
        if (grammar != null) {
          for (name in grammar) {
            if (!__hasProp.call(grammar, name)) continue;
            alternatives = grammar[name];
            this.grammar_rule.apply(this, [name].concat(__slice.call(alternatives)));
          }
        }
        this.parser = new JisonParser({
          lex: this.lexer,
          operators: this.operators,
          bnf: this.grammar,
          startSymbol: this.start
        });
      }

      Parser.prototype.lex_rule = function(pattern, ret) {
        var jison_pattern, jison_ret;
        if (L.core.to_type(pattern) === 'regexp') {
          jison_pattern = pattern.source;
        } else if (!this.re.jison_special.test(pattern)) {
          jison_pattern = pattern.replace(this.re.regex_special, "\\$&");
        }
        if (!(ret != null)) {
          jison_ret = pattern;
        }
        if (L.core.to_type(ret) !== 'string') {
          ret = String(ret);
        }
        jison_ret = L.core.s_trim.call(ret);
        if (!this.re.comment.test(jison_ret)) {
          if (!this.re.lex_return.test(jison_ret)) {
            jison_ret = "return '" + jison_ret + "';";
          } else if (this.re.lex_function.test(jison_ret)) {
            jison_ret = jison_ret.replace(this.re.strip_function, '');
          }
        }
        return this.lexer.rules.push([jison_pattern, jison_ret]);
      };

      Parser.prototype.grammar_rule = function() {
        var action, alt, alternatives, jison_action, match, name, options, pattern;
        name = arguments[0], alternatives = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return this.grammar[name] = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = alternatives.length; _i < _len; _i++) {
            alt = alternatives[_i];
            pattern = alt[0], action = alt[1], options = alt[2];
            if (action != null) {
              action = (match = this.re.unwrap_function.exec(action)) ? match[1] : "(" + action + "())";
              jison_action = "$$ = " + action + ";";
            } else {
              jison_action = "$$ = $1;";
            }
            if (name === this.start) {
              jison_action += " return $$;";
            }
            _results.push([pattern, jison_action, options]);
          }
          return _results;
        }).call(this);
      };

      Parser.prototype.operator_rule = function() {
        var op1, ops;
        ops = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (ops.length === 1) {
          ops = ops[0];
        }
        if (L.core.to_type(ops) === 'string') {
          ops = ops.split(this.re.whitespace);
        }
        if (ops.length === 2) {
          op1 = ops.pop().split(this.re.whitespace);
          ops = ops.concat(op1);
        }
        return this.operators.push(ops);
      };

      return Parser;

    })(JisonParser);
    L.parser = function(config) {
      return (new Parser(config)).parser;
    };
    if (typeof exports !== "undefined" && exports !== null) {
      if (typeof module !== "undefined" && module !== null) {
        module.exports = L.parser;
      }
    }
  }

  L = lemur;

  C = L.Compiler = (function() {

    function Compiler(config) {
      var _ref1;
      if (config == null) {
        config = {};
      }
      this.predefined = config.predefined, this.parent_context = config.parent_context;
      C.current_context = this;
      this.scope_stack = ((_ref1 = this.parent_context) != null ? _ref1.scope_stack.slice() : void 0) || [];
      this.new_scope();
      this.global_scope = this.current_scope();
    }

    Compiler.prototype.new_scope = function() {
      return this.push_scope(new C.Scope({
        push_to_current: false
      }));
    };

    Compiler.prototype.push_scope = function(scope) {
      this.scope_stack.push(scope);
      return scope;
    };

    Compiler.prototype.pop_scope = function() {
      return this.scope_stack.pop();
    };

    Compiler.prototype.current_scope = function() {
      return this.scope_stack[this.scope_stack.length - 1];
    };

    Compiler.prototype.find_scope_with_var = function(_var) {
      var scope, _i, _len, _ref1;
      _ref1 = this.scope_stack.slice().reverse();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        scope = _ref1[_i];
        if (scope.var_defined(_var)) {
          return scope;
        }
      }
      return null;
    };

    Compiler.prototype.get_var_val = function(_var) {
      var scope;
      scope = this.find_scope_with_var(_var);
      if (scope != null) {
        return scope.get_val(_var);
      }
    };

    Compiler.prototype.set_var_val = function(_var, val) {
      var scope;
      scope = this.find_scope_with_var(_var);
      if (scope != null) {
        return scope.set_var(_var, val);
      } else {
        return _var.error_cant_set();
      }
    };

    Compiler.prototype.compile = function(fn) {
      return fn.call(this);
    };

    Compiler.current_scope = function() {
      return this.current_context.current_scope();
    };

    Compiler.push_scope = function() {
      var _ref1;
      return (_ref1 = this.current_context).push_scope.apply(_ref1, arguments);
    };

    Compiler.pop_scope = function() {
      return this.current_context.pop_scope();
    };

    Compiler.new_scope = function() {
      var _ref1;
      return (_ref1 = this.current_context).new_scope.apply(_ref1, arguments);
    };

    Compiler.find_scope_with_var = function() {
      var _ref1;
      return (_ref1 = this.current_context).find_scope_with_var.apply(_ref1, arguments);
    };

    Compiler.get_var_val = function() {
      var _ref1;
      return (_ref1 = this.current_context).get_var_val.apply(_ref1, arguments);
    };

    Compiler.set_var_val = function() {
      var _ref1;
      return (_ref1 = this.current_context).set_var_val.apply(_ref1, arguments);
    };

    return Compiler;

  })();

  C.Construct = (function() {

    function Construct(value, yy_or_node_or_num) {
      var _ref1;
      this.value = value;
      if (yy_or_node_or_num instanceof Construct) {
        this.transfer_node = yy_or_node_or_num;
        this.yy = yy_or_node_or_num.yy;
      } else if ((L.core.to_type(yy_or_node_or_num)) === "number") {
        this.yy = {
          lexer: {
            yylineno: yy_or_node_or_num
          }
        };
      } else {
        this.yy = yy_or_node_or_num;
      }
      this.line_number = (_ref1 = this.yy) != null ? _ref1.lexer.yylineno : void 0;
    }

    Construct.prototype.compile = function() {
      if (this.value != null) {
        return "" + this.value;
      } else {
        return "null";
      }
    };

    Construct.prototype._compile = function() {
      return this.compile.apply(this, arguments);
    };

    Construct.prototype.error = function(message) {
      var filename, location, type;
      filename = C.current_filename;
      location = "";
      type = "";
      if (filename != null) {
        location += " in " + filename;
      }
      if (this.line_number != null) {
        location += " at line " + this.line_number;
      }
      if (this.constructor.name != null) {
        type = "" + this.constructor.name;
      }
      throw "" + type + "Error" + location + ": " + message;
    };

    Construct.prototype.should_return = function() {
      return new C.ReturnedConstruct(this, this.yy);
    };

    return Construct;

  })();

  C.ReturnedConstruct = (function(_super) {

    __extends(ReturnedConstruct, _super);

    function ReturnedConstruct() {
      return ReturnedConstruct.__super__.constructor.apply(this, arguments);
    }

    ReturnedConstruct.prototype.compile = function() {
      var c_value;
      c_value = this.value._compile();
      if (!this.disabled) {
        return "return " + c_value;
      } else {
        return c_value;
      }
    };

    ReturnedConstruct.prototype.tail_node = function(node) {
      if (!(node != null)) {
        return this;
      } else {
        if (node instanceof C.ReturnedConstruct) {
          node = node.value;
        }
        this.value = node;
        return node.returnedConstruct = this;
      }
    };

    ReturnedConstruct.prototype.should_return = function() {
      return this;
    };

    return ReturnedConstruct;

  })(C.Construct);

  C.Array = (function(_super) {

    __extends(Array, _super);

    function Array(items) {
      this.items = items;
      Array.__super__.constructor.apply(this, arguments);
    }

    Array.prototype.compile = function() {
      var c_items, item;
      c_items = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.items;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          _results.push(item._compile());
        }
        return _results;
      }).call(this);
      return "[" + (c_items.join(', ')) + "]";
    };

    return Array;

  })(C.Construct);

  C.Atom = (function(_super) {

    __extends(Atom, _super);

    function Atom(y, yy) {
      Atom.__super__.constructor.call(this, null, y || yy);
    }

    return Atom;

  })(C.Construct);

  C.Null = (function(_super) {

    __extends(Null, _super);

    function Null() {
      return Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.compile = function() {
      return "null";
    };

    return Null;

  })(C.Atom);

  C.Undefined = (function(_super) {

    __extends(Undefined, _super);

    function Undefined() {
      return Undefined.__super__.constructor.apply(this, arguments);
    }

    Undefined.prototype.compile = function() {
      return "void(0)";
    };

    return Undefined;

  })(C.Atom);

  C.Boolean = (function(_super) {

    __extends(Boolean, _super);

    function Boolean() {
      return Boolean.__super__.constructor.apply(this, arguments);
    }

    return Boolean;

  })(C.Atom);

  C.True = (function(_super) {

    __extends(True, _super);

    function True() {
      return True.__super__.constructor.apply(this, arguments);
    }

    True.prototype.compile = function() {
      return "true";
    };

    return True;

  })(C.Boolean);

  C.False = (function(_super) {

    __extends(False, _super);

    function False() {
      return False.__super__.constructor.apply(this, arguments);
    }

    False.prototype.compile = function() {
      return "false";
    };

    return False;

  })(C.Boolean);

  C.This = (function(_super) {

    __extends(This, _super);

    function This() {
      return This.__super__.constructor.apply(this, arguments);
    }

    This.prototype.compile = function() {
      return "this";
    };

    return This;

  })(C.Construct);

  C.Class = (function(_super) {

    __extends(Class, _super);

    Class.prototype.anon_id = 0;

    function Class(config, yy) {
      var constructor, _ref1, _ref2, _ref3;
      if (config == null) {
        config = {};
      }
      Class.__super__.constructor.apply(this, arguments);
      if (!config.hasOwnProperty('constructor')) {
        config.constructor = null;
      }
      this.name = config.name, constructor = config.constructor, this.prototype = config.prototype, this.statics = config.statics;
      if ((_ref1 = this.name) == null) {
        this.name = new C.String("Anonymous_$" + (id++) + "_");
      }
      this.class_constructor = constructor != null ? constructor : new C.Function({}, yy);
      if ((_ref2 = this.prototype) == null) {
        this.prototype = new C.Object([], yy);
      }
      if ((_ref3 = this.statics) == null) {
        this.statics = new C.Object([], yy);
      }
      this.class_constructor.name = this.name;
    }

    Class.prototype.object_compile = function(prefix, obj) {
      var pairs, prop, val;
      pairs = (function() {
        var _i, _len, _ref1, _ref2, _results;
        _ref1 = obj.property_value_pairs;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], prop = _ref2[0], val = _ref2[1];
          _results.push("" + prefix + "." + (prop._compile()) + " = " + (val._compile()));
        }
        return _results;
      })();
      return pairs.join(';\n  ');
    };

    Class.prototype.compile = function() {
      var proto, statics;
      statics = object_compile(this.name, this.statics);
      proto = object_compile("" + this.name + ".prototype", this.prototype);
      return "" + this.name + " = (function () {\n  " + (this.class_constructor._compile()) + ";\n  " + statics + ";\n  " + proto + ";\n  return " + this.name + ";\n})()";
    };

    return Class;

  })(C.Construct);

  C.CodeFragment = (function(_super) {

    __extends(CodeFragment, _super);

    function CodeFragment(statements) {
      this.statements = statements;
      CodeFragment.__super__.constructor.apply(this, arguments);
    }

    CodeFragment.prototype.compile = function() {
      var c_statements, stmt;
      c_statements = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.statements;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          stmt = _ref1[_i];
          _results.push(stmt.compile());
        }
        return _results;
      }).call(this);
      return "" + (c_statements.join(';\n'));
    };

    return CodeFragment;

  })(C.Construct);

  C.CommaGroup = (function(_super) {

    __extends(CommaGroup, _super);

    function CommaGroup(items) {
      this.items = items;
      CommaGroup.__super__.constructor.apply(this, arguments);
    }

    CommaGroup.prototype.compile = function() {
      var c_items, item;
      c_items = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.items;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          _results.push(item._compile());
        }
        return _results;
      }).call(this);
      return "(" + (c_items.join(', ')) + ")";
    };

    return CommaGroup;

  })(C.Construct);

  C.Function = (function(_super) {

    __extends(Function, _super);

    function Function(_arg) {
      var _ref1, _ref2, _ref3;
      this.name = _arg.name, this.args = _arg.args, this.body = _arg.body, this.autoreturn = _arg.autoreturn;
      if ((_ref1 = this.name) == null) {
        this.name = '';
      }
      if ((_ref2 = this.args) == null) {
        this.args = [];
      }
      if ((_ref3 = this.body) == null) {
        this.body = [];
      }
      Function.__super__.constructor.apply(this, arguments);
    }

    Function.prototype.compile = function() {
      var arg, arg_redefs, body, c_args, c_body, c_name, fake_arg, fake_arg_defs, fake_args, fake_fn_call, fn, i, result, ret, scope, stmt, sym_continue, sym_fn, sym_result, tail_recursive, to_return, to_return_context, var_stmt, _continuef, _continuet, _i, _len, _ref1, _ref2, _while;
      scope = new C.Scope();
      _ref1 = this.will_autoreturn(), to_return = _ref1.to_return, to_return_context = _ref1.to_return_context;
      tail_recursive = this.autoreturn && to_return.value instanceof C.FunctionCall && to_return.value.fn instanceof C.Symbol && to_return.value.fn.name === this.name.name;
      body = this.body;
      if (tail_recursive) {
        sym_continue = C.Var.gensym("continue");
        fake_args = {};
        fake_arg_defs = [];
        arg_redefs = [];
        _ref2 = this.args;
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          arg = _ref2[i];
          fake_arg = fake_args[arg.name] = C.Var.gensym(arg);
          fake_arg_defs.push(new C.Var.Set({
            _var: fake_arg,
            value: to_return.value.args[i]
          }));
          arg_redefs.push(new C.Var.Set({
            _var: arg,
            value: fake_arg,
            must_exist: false
          }));
        }
        _continuet = new C.Var.Set({
          _var: sym_continue,
          value: new C.True()
        });
        _continuef = new C.Var.Set({
          _var: sym_continue,
          value: new C.False()
        });
        fake_fn_call = new C.CodeFragment(fake_arg_defs.concat(arg_redefs, _continuet));
        body.unshift(_continuef);
        to_return.return_disabled = true;
        to_return_context.tail_node(fake_fn_call);
        fake_fn_call.returnedConstruct.disabled = true;
        sym_result = C.Var.gensym("result");
        sym_fn = C.Var.gensym("fn");
        fn = new C.Var.Set({
          _var: sym_fn,
          value: new C.Function({
            body: body
          })
        });
        result = new C.Var.Set({
          _var: sym_result,
          value: new C.FunctionCall({
            fn: sym_fn,
            scope: new C.This()
          })
        });
        ret = new C.If({
          condition: new C.Not(sym_continue),
          then: new C.ReturnedConstruct(sym_result)
        });
        _while = new C.WhileLoop({
          condition: new C.True(),
          body: [result, ret]
        });
        body = [fn, _while];
      }
      c_name = L.core.to_type(this.name) === "string" ? this.name : this.name._compile();
      c_args = (function() {
        var _j, _len1, _ref3, _results;
        _ref3 = this.args;
        _results = [];
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          arg = _ref3[_j];
          _results.push(arg._compile());
        }
        return _results;
      }).call(this);
      c_body = (function() {
        var _j, _len1, _results;
        _results = [];
        for (i = _j = 0, _len1 = body.length; _j < _len1; i = ++_j) {
          stmt = body[i];
          _results.push(stmt._compile());
        }
        return _results;
      })();
      var_stmt = scope.var_stmt();
      return "function " + c_name + "(" + (c_args.join(", ")) + ") {\n  " + var_stmt + (c_body.join(";\n  ")) + ";\n}";
    };

    Function.prototype.will_autoreturn = function() {
      var ret, to_return;
      if (this.autoreturn) {
        to_return = this.body.pop();
        to_return = to_return.should_return();
        this.body.push(to_return);
        ret = {
          to_return: to_return.tail_node(),
          to_return_context: to_return
        };
      }
      return ret || {};
    };

    return Function;

  })(C.Construct);

  C.FunctionCall = (function(_super) {

    __extends(FunctionCall, _super);

    function FunctionCall(_arg, yy) {
      var _ref1;
      this.fn = _arg.fn, this.args = _arg.args, this.scope = _arg.scope, this.apply = _arg.apply;
      this.call = !!this.scope;
      if ((_ref1 = this.scope) == null) {
        this.scope = new C.Null(null, yy);
      }
      this.args || (this.args = []);
    }

    FunctionCall.prototype.compile = function() {
      var arg, args, c_args, c_fn;
      c_fn = this.fn._compile();
      if (!(this.fn instanceof C.Symbol)) {
        c_fn = "(" + c_fn + ")";
      }
      if (this.apply || this.call) {
        args = [this.scope].concat(this.args);
      } else {
        args = this.args;
      }
      c_args = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          arg = args[_i];
          _results.push(arg._compile());
        }
        return _results;
      })();
      return "" + c_fn + (this.apply ? '.apply' : this.call ? '.call' : '') + "(" + (c_args.join(', ')) + ")";
    };

    return FunctionCall;

  })(C.Construct);

  C.If = (function(_super) {

    __extends(If, _super);

    function If(_arg) {
      this.condition = _arg.condition, this.then = _arg.then, this._else = _arg._else;
      If.__super__.constructor.apply(this, arguments);
    }

    If.prototype.compile = function() {
      var c_cond, c_else, c_then, ret;
      c_cond = this.condition.compile();
      c_then = this.then.compile();
      ret = "if (" + c_cond + ") {\n  " + c_then + "\n}";
      if (this._else) {
        c_else = this._else.compile();
        ret = "" + ret + " else {\n  " + c_else + "\n}";
      }
      return ret;
    };

    If.prototype.should_return = function() {
      this.then = this.then.should_return();
      if (this._else) {
        this._else = this._else.should_return();
      }
      return this;
    };

    If.prototype.tail_node = function() {
      var _ref1, _ref2;
      if (this._else != null) {
        return (_ref1 = this._else).tail_node.apply(_ref1, arguments);
      } else {
        return (_ref2 = this.then).tail_node.apply(_ref2, arguments);
      }
    };

    return If;

  })(C.Construct);

  C.Loop = (function(_super) {

    __extends(Loop, _super);

    function Loop() {
      return Loop.__super__.constructor.apply(this, arguments);
    }

    Loop.BREAK = {
      compile: function() {
        return "break";
      }
    };

    Loop.CONTINUE = {
      compile: function() {
        return "continue";
      }
    };

    return Loop;

  })(C.Construct);

  C.ForLoop = (function(_super) {

    __extends(ForLoop, _super);

    function ForLoop(_arg) {
      var condition;
      condition = _arg.condition, this.body = _arg.body;
      this.a = condition[0], this.b = condition[1], this.c = condition[2];
      ForLoop.__super__.constructor.apply(this, arguments);
    }

    ForLoop.prototype.compile = function() {
      var c_a, c_b, c_body, c_c, item;
      c_a = this.a._compile();
      c_b = this.b._compile();
      c_c = this.c._compile();
      c_body = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.body;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          _results.push(item._compile());
        }
        return _results;
      }).call(this);
      return "for (" + c_a + "; " + c_b + "; " + c_c + ") {\n	" + (c_body.join(';\n  ')) + ";\n}";
    };

    return ForLoop;

  })(C.Loop);

  C.ForEachLoop = (function(_super) {

    __extends(ForEachLoop, _super);

    function ForEachLoop(_arg, yy) {
      var a, b, c, i, len, vlen;
      this.collection = _arg.collection, this.body = _arg.body;
      i = C.Var.gensym("i", yy);
      vlen = C.Var.gensym("len", yy);
      len = new C.PropertyAccess([this.collection, C.Symbol("length")]);
      a = new C.Comma(C.Var.Set({
        "var": i,
        value: C.Number(0, yy)
      }), C.Var.Set({
        "var": vlen,
        value: len
      }));
      b = new C.LT([i, len]);
      c = new C.PostIncr(i);
      ForEachLoop.__super__.constructor.call(this, [a, b, c], yy);
    }

    return ForEachLoop;

  })(C.ForLoop);

  C.ForInLoop = (function(_super) {

    __extends(ForInLoop, _super);

    function ForInLoop(_arg) {
      this.property = _arg.property, this.object = _arg.object, this.body = _arg.body;
      ForInLoop.__super__.constructor.apply(this, arguments);
    }

    ForInLoop.prototype.compile = function() {
      var c_body, c_object, c_property, item;
      c_property = this.property._compile();
      c_object = this.object._compile();
      c_body = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.body;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          _results.push(item._compile());
        }
        return _results;
      }).call(this);
      return "for (" + c_property + " in " + c_object + ") {\n  " + (c_body.join(';\n  ')) + ";\n}";
    };

    return ForInLoop;

  })(C.Loop);

  C.WhileLoop = (function(_super) {

    __extends(WhileLoop, _super);

    function WhileLoop(_arg) {
      this.condition = _arg.condition, this.body = _arg.body;
      WhileLoop.__super__.constructor.apply(this, arguments);
    }

    WhileLoop.prototype.compile = function() {
      var c_body, c_condition, item;
      c_condition = this.condition._compile();
      c_body = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.body;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          _results.push(item._compile());
        }
        return _results;
      }).call(this);
      return "while (" + c_condition + ") {\n  " + (c_body.join(';\n  ')) + ";\n}";
    };

    return WhileLoop;

  })(C.Loop);

  C.DoWhileLoop = (function(_super) {

    __extends(DoWhileLoop, _super);

    function DoWhileLoop(_arg) {
      this.condition = _arg.condition, this.body = _arg.body;
      DoWhileLoop.__super__.constructor.apply(this, arguments);
    }

    DoWhileLoop.prototype.compile = function() {
      var c_body, c_condition, item;
      c_condition = this.condition._compile();
      c_body = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.body;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          _results.push(item._compile());
        }
        return _results;
      }).call(this);
      return "do {\n  " + (c_body.join(';\n  ')) + ";\n} while (" + c_condition + ")";
    };

    return DoWhileLoop;

  })(C.Loop);

  C.Number = (function(_super) {

    __extends(Number, _super);

    function Number(n) {
      var base, o, value;
      Number.__super__.constructor.apply(this, arguments);
      if ((L.core.to_type(n)) === "object") {
        o = n;
        value = o.value, base = o.base;
        if (base) {
          n = parseInt(value, base);
        } else {
          n = value;
        }
      }
      this.value = +n;
    }

    Number.prototype.compile = function() {
      return "" + this.value;
    };

    return Number;

  })(C.Construct);

  C.Object = (function(_super) {

    __extends(Object, _super);

    function Object(property_value_pairs) {
      this.property_value_pairs = property_value_pairs != null ? property_value_pairs : [];
      Object.__super__.constructor.apply(this, arguments);
    }

    Object.prototype.compile = function() {
      var pairs, prop, val;
      pairs = (function() {
        var _i, _len, _ref1, _ref2, _results;
        _ref1 = this.property_value_pairs;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], prop = _ref2[0], val = _ref2[1];
          _results.push("" + (prop._compile()) + ": " + (val._compile()));
        }
        return _results;
      }).call(this);
      return "{ " + (pairs.join(',\n  ')) + " }";
    };

    return Object;

  })(C.Construct);

  C.ProperyAccess = (function(_super) {

    __extends(ProperyAccess, _super);

    function ProperyAccess(_arg) {
      this.obj = _arg[0], this.props = 2 <= _arg.length ? __slice.call(_arg, 1) : [];
      ProperyAccess.__super__.constructor.apply(this, arguments);
    }

    ProperyAccess.prototype.compile = function() {
      var base, c_prop, prop, _i, _len, _ref1, _results;
      base = this.obj._compile();
      _ref1 = this.props;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        prop = _ref1[_i];
        c_prop = prop._compile();
        if (prop instanceof C.Var) {
          _results.push(base = "" + base + "." + c_prop);
        } else {
          _results.push(base = "" + base + "[" + c_prop + "]");
        }
      }
      return _results;
    };

    return ProperyAccess;

  })(C.Construct);

  C.Operation = (function(_super) {

    __extends(Operation, _super);

    function Operation(_arg) {
      this.x = _arg[0], this.op = _arg[1], this.y = _arg[2];
      Operation.__super__.constructor.apply(this, arguments);
    }

    Operation.prototype.compile = function() {
      var c_x, c_y;
      c_x = this.x._compile();
      c_y = this.y._compile();
      return "" + c_x + " " + this.op + " " + c_y;
    };

    return Operation;

  })(C.Construct);

  C.PrefixOperation = (function(_super) {

    __extends(PrefixOperation, _super);

    function PrefixOperation(_arg) {
      this.x = _arg[0], this.op = _arg[1];
      PrefixOperation.__super__.constructor.apply(this, arguments);
    }

    PrefixOperation.prototype.compile = function() {
      var c_x;
      c_x = this.x._compile();
      return "" + this.op + c_x;
    };

    return PrefixOperation;

  })(C.Operation);

  C.PostfixOperation = (function(_super) {

    __extends(PostfixOperation, _super);

    function PostfixOperation(_arg) {
      this.x = _arg[0], this.op = _arg[1];
      PostfixOperation.__super__.constructor.apply(this, arguments);
    }

    PostfixOperation.prototype.compile = function() {
      var c_x;
      c_x = this.x._compile();
      return "" + c_x + this.op;
    };

    return PostfixOperation;

  })(C.Operation);

  regular_ops = {
    Add: "+",
    Subtract: "-",
    Multiply: "*",
    Divide: "/",
    Mod: "%",
    GT: ">",
    LT: "<",
    GTE: ">=",
    LTE: "<=",
    Eq3: "===",
    Eq2: "==",
    NotEq3: "!==",
    NotEq2: "!=",
    And: "&&",
    Or: "||",
    BAnd: "&",
    BOr: "|",
    BXor: "^",
    BLeftShift: "<<",
    BRightShift: ">>",
    BZeroFillRightShift: ">>>",
    Comma: ","
  };

  prefix_ops = {
    Not: "!",
    BNot: "~",
    PreIncr: "++",
    PreDecr: "--",
    Delete: "delete "
  };

  postfix_ops = {
    PostIncr: "++",
    PostDecr: "--"
  };

  _fn = function(name, op) {
    return C[name] = (function(_super) {

      __extends(_Class, _super);

      function _Class(_arg, yy) {
        var x, y;
        x = _arg[0], y = _arg[1];
        _Class.__super__.constructor.call(this, [x, op, y], yy);
      }

      return _Class;

    })(C.Operation);
  };
  for (name in regular_ops) {
    if (!__hasProp.call(regular_ops, name)) continue;
    op = regular_ops[name];
    _fn(name, op);
  }

  _fn1 = function(name, op) {
    return C[name] = (function(_super) {

      __extends(_Class, _super);

      function _Class(x, yy) {
        _Class.__super__.constructor.call(this, [x, op], yy);
      }

      return _Class;

    })(C.PrefixOperation);
  };
  for (name in prefix_ops) {
    if (!__hasProp.call(prefix_ops, name)) continue;
    op = prefix_ops[name];
    _fn1(name, op);
  }

  _fn2 = function(name, op) {
    return C[name] = (function(_super) {

      __extends(_Class, _super);

      function _Class(x, yy) {
        _Class.__super__.constructor.call(this, [x, op], yy);
      }

      return _Class;

    })(C.PostfixOperation);
  };
  for (name in postfix_ops) {
    if (!__hasProp.call(postfix_ops, name)) continue;
    op = postfix_ops[name];
    _fn2(name, op);
  }

  C.Raw = (function(_super) {

    __extends(Raw, _super);

    function Raw(text) {
      this.text = text;
    }

    Raw.prototype.compile = function() {
      return this.text;
    };

    return Raw;

  })(C.Construct);

  C.Regex = (function(_super) {

    __extends(Regex, _super);

    function Regex(_arg) {
      this.pattern = _arg.pattern, this.modifiers = _arg.modifiers;
      Regex.__super__.constructor.apply(this, arguments);
    }

    Regex.prototype.compile = function() {
      return "/" + this.pattern + "/" + this.modifiers;
    };

    return Regex;

  })(C.Construct);

  C.Scope = (function() {

    function Scope(config) {
      var push_to_current;
      if (config == null) {
        config = {};
      }
      push_to_current = config.push_to_current;
      this.last_scope = C.current_scope();
      this.vars = {};
      if (push_to_current == null) {
        push_to_current = true;
      }
      if (push_to_current) {
        C.push_scope(this);
      }
    }

    Scope.prototype.def_var = function(_var, val) {
      if (this.var_defined(_var)) {
        _var.error_cant_redefine();
      }
      return this.vars[_var.name] = {
        _var: _var,
        val: val
      };
    };

    Scope.prototype.var_defined = function(_var) {
      return _var.name in this.vars;
    };

    Scope.prototype.set_var = function(_var, val) {
      if (!this.var_defined(_var)) {
        _var.error_cant_set();
      }
      return this.vars[_var.name].val = val;
    };

    Scope.prototype.get_val = function(_var) {
      var _ref1;
      return (_ref1 = this.vars[_var.name]) != null ? _ref1.val : void 0;
    };

    Scope.prototype.quiet_def_var = function(_var) {
      try {
        return this.def_var(_var);
      } catch (_error) {}
    };

    Scope.prototype.var_stmt = function() {
      var c_vars, _var;
      if (Object.keys(this.vars).length) {
        c_vars = (function() {
          var _ref1, _results;
          _ref1 = this.vars;
          _results = [];
          for (name in _ref1) {
            if (!__hasProp.call(_ref1, name)) continue;
            _var = _ref1[name]._var;
            _results.push(_var._compile());
          }
          return _results;
        }).call(this);
        return "var " + (c_vars.join(', ')) + ";\n";
      } else {
        return '';
      }
    };

    return Scope;

  })();

  C.String = (function(_super) {

    __extends(String, _super);

    function String(value) {
      this.value = value;
      String.__super__.constructor.apply(this, arguments);
    }

    String.prototype.compile = function() {
      var value;
      value = this.value.replace(/'/, "\\'");
      return "'" + value + "'";
    };

    String.prototype.toString = function() {
      return this.compile();
    };

    return String;

  })(C.Construct);

  C.Symbol = (function(_super) {

    __extends(Symbol, _super);

    function Symbol(name) {
      this.name = name;
      if (this.name instanceof C.Symbol) {
        this.name = this.name.name;
      }
      Symbol.__super__.constructor.apply(this, arguments);
    }

    Symbol.prototype.compile = function() {
      return C.Var.text_to_js_identifier(this.name);
    };

    Symbol.prototype.error_cant_redefine = function() {
      return this.error("Can't redefine var " + this.name);
    };

    Symbol.prototype.error_cant_set = function() {
      return this.error("Can't set nonexistant var " + this.name);
    };

    Symbol.gensym = function(s, yy) {
      var now, rand;
      if (s == null) {
        s = "sym";
      }
      if (s instanceof C.Symbol) {
        s = s.name;
      }
      now = (+new Date()).toString(36);
      rand = Math.floor(Math.random() * 1e6).toString(36);
      return new this("" + s + "-" + rand + "-" + now, yy);
    };

    Symbol.text_to_js_identifier = function(text, conversions) {
      var _char_wrapper;
      if ((this.JS_KEYWORDS.indexOf(text)) >= 0) {
        return this.wrapper(text);
      }
      if (text.length === 0) {
        return this.wrapper("null");
      }
      _char_wrapper = this.char_wrapper.bind(this, conversions);
      return ((text.replace(this.WRAPPER_REGEX, this.wrapper)).replace(/^\d/, _char_wrapper)).replace(/[^\w\$]/g, _char_wrapper);
    };

    Symbol.char_wrapper = function(conversions, _char) {
      var txt, _ref1, _ref2;
      if (conversions == null) {
        conversions = {};
      }
      txt = (_ref1 = (_ref2 = conversions[_char]) != null ? _ref2 : this.JS_ILLEGAL_IDENTIFIER_CHARS[_char]) != null ? _ref1 : "ASCII_" + (_char.charCodeAt(0));
      return this.wrapper(txt);
    };

    Symbol.wrapper = function(text) {
      return "" + this.WRAPPER_PREFIX + text + this.WRAPPER_SUFFIX;
    };

    Symbol.WRAPPER_PREFIX = "_$";

    Symbol.WRAPPER_SUFFIX = "_";

    Symbol.WRAPPER_REGEX = /_\$[^_]+_/g;

    Symbol.JS_KEYWORDS = ["break", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "enum", "export", "extends", "false", "finally", "for", "function", "if", "implements", "import", "in", "instanceof", "interface", "let", "new", "null", "package", "private", "protected", "public", "return", "static", "switch", "super", "this", "throw", "true", "try", "typeof", "undefined", "var", "void", "while", "with", "yield"];

    Symbol.JS_ILLEGAL_IDENTIFIER_CHARS = {
      "~": "tilde",
      "`": "backtick",
      "!": "exclamationmark",
      "@": "at",
      "#": "pound",
      "%": "percent",
      "^": "carat",
      "&": "amperstand",
      "*": "asterisk",
      "(": "leftparen",
      ")": "rightparen",
      "-": "dash",
      "+": "plus",
      "=": "equals",
      "{": "leftcurly",
      "}": "rightcurly",
      "[": "leftsquare",
      "]": "rightsquare",
      "|": "pipe",
      "\\": "backslash",
      "\"": "doublequote",
      "'": "singlequote",
      ":": "colon",
      ";": "semicolon",
      "<": "leftangle",
      ">": "rightangle",
      ",": "comma",
      ".": "period",
      "?": "questionmark",
      "/": "forwardslash",
      " ": "space",
      "\t": "tab",
      "\n": "newline",
      "\r": "carriagereturn"
    };

    return Symbol;

  })(C.Construct);

  C.Var = (function(_super) {

    __extends(Var, _super);

    function Var() {
      var scope;
      Var.__super__.constructor.apply(this, arguments);
      scope = C.current_scope();
      scope.def_var(this);
    }

    return Var;

  })(C.Symbol);

  C.Var.Set = (function(_super) {

    __extends(Set, _super);

    function Set(_arg, yy) {
      var scope, value, _ref1;
      this._var = _arg._var, value = _arg.value, this.must_exist = _arg.must_exist;
      Set.__super__.constructor.apply(this, arguments);
      this.value = value;
      scope = C.find_scope_with_var(this._var);
      if ((_ref1 = this.must_exist) == null) {
        this.must_exist = true;
      }
      if (this.must_exist && !scope) {
        this._var.error_cant_set();
      }
    }

    Set.prototype.compile = function() {
      var c_val, c_var;
      c_var = this._var._compile();
      c_val = this.value._compile();
      return "" + c_var + " = " + c_val;
    };

    return Set;

  })(C.Construct);

}).call(this);
